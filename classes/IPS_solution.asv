classdef IPS_solution < dynamicprops
    % needs to be derived from dynamicprops because slip_solution can dynamically add e.g. OR directions!
    % IPS_solution - Baseclass for solutions of the IPS equation: F1 - F2 = eps0 * (d \dyad h)
    
    properties (Access = public)
        F1 = zeros(3); % F1=U1 R1 e.g. modified Bain strain BS or 0.5*( R*S + inverse(R)*S_mirror ) * B as in Qi2013
        F2 = zeros(3); % F2=U2 R2 this should be the reference deformation, e.g. Identiy for austenite, or fixed U_i for twins
        id = 0;
        eps_ips = 0.; % strain: lambda_3 - lambda_1 or sqrt respectively depending on convention
        h = [0. 0. 0.]'; % normal vector to habit plane (unit vector)
        d = [0. 0. 0.]'; % shear direction of transformation (unit vector)
        Q = zeros(3); % rotation matrix (for invariant planar match between domains of homogeneous deformation F and G
        LT = zeros(3); % calculation of Lattice-Transformation (A_L in Qi2014 Paper)
        %LT; % = RB = ...R von IPS condition
    end
    properties (Dependent)
        % shape transformation (A_D in Qi2014 Paper)
        ST;  % on side of homogeneous deformation F:  QF - G = eps_0* ( a \dyad n )
        dir_of_largest_def;
        dir_of_smallest_def;
        rot_angle_inclusion;
    end
    
    methods
        % constructor: The constructor can return only a single argument.
        function obj = IPS_solution( varargin ) % F1, F2, id, eps, a, h, Q, LT)
            if isempty(varargin)
                return; % no argument constructor
            end
            %
            if nargin == 8 % constructor from solution arguments
                obj.F1 = varargin{1};
                obj.F2  = varargin{2};
                obj.id = varargin{3};
                obj.eps_ips= varargin{4};
                obj.d  = varargin{5};
                obj.h  = varargin{6};
                obj.Q  = varargin{7};
                obj.LT = varargin{8}; % the lattice transformation = Q*Bain is given here directly so that the class does not need the Bain strain as property (only needed for this)
            end
        end
        
        %
        function shape_transformation = get.ST( obj )
            shape_transformation = obj.Q * obj.F1; % = G + eps_0 ( a \dyad n )
        end
        %
        function smallest_eigenvector = get.dir_of_smallest_def( obj )
            [~,~,~,smallest_eigenvector] = sorted_eig_vals_and_vecs(); % [ y1, y2, y3, e1, e2, e3] = 
        end
        %
        function largest_eigenvector = get.dir_of_largest_def( obj )
            [~,~,~,~,~,largest_eigenvector] = sorted_eig_vals_and_vecs(); % [ y1, y2, y3, e1, e2, e3] =
        end
        %
        function alpha = get.rot_angle_inclusion( obj )
            alpha = 
        end
        %         function lattice_transformation = get.LT( obj )
        %             lattice_transformation = obj.Q * obj.U; % = G + eps_0 ( a \dyad n )   %%%%%%%%% Problem like this is that the bain strain would occur in two classes...
        %         end                                                                       %%%%%%%%% Or, if this class is derived from martensite - the object array contains to much data...       
        
    end % methdos
end % class



